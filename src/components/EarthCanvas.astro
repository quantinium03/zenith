<div class="earth-container">
  <canvas id="solar-canvas"></canvas>
</div>

<script>
import * as THREE from 'three';

document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('solar-canvas');
  if (!canvas) {
    console.error('Canvas not found!');
    return;
  }

  const container = canvas.parentElement;
  let width = container.clientWidth;
  let height = container.clientHeight;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true
  });
  renderer.setSize(width, height);

  const textureLoader = new THREE.TextureLoader();
  const textureURLBase = '/'; // Adjust this path to your texture location

  const earthGroup = new THREE.Group();
  const earthGeometry = new THREE.SphereGeometry(0.8, 64, 64);
  const earthMaterial = new THREE.MeshPhongMaterial({
    map: textureLoader.load(`${textureURLBase}earth.jpg`),
    shininess: 10
  });

  const earth = new THREE.Mesh(earthGeometry, earthMaterial);
  earthGroup.add(earth);

  const cloudGeometry = new THREE.SphereGeometry(0.82, 64, 64);
  const cloudMaterial = new THREE.MeshPhongMaterial({
    map: textureLoader.load(`${textureURLBase}clouds.jpg`),
    transparent: true,
    opacity: 0.5
  });
  const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
  earthGroup.add(clouds);

  const atmosphereGeometry = new THREE.SphereGeometry(0.9, 64, 64);
  const atmosphereMaterial = new THREE.MeshPhongMaterial({
    color: 0xADD8FF,
    transparent: true,
    opacity: 0.1,
    side: THREE.BackSide
  });
  const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
  earthGroup.add(atmosphere);
  scene.add(earthGroup);

  const marsGroup = new THREE.Group();
  const marsGeometry = new THREE.SphereGeometry(0.5, 64, 64);
  const marsMaterial = new THREE.MeshPhongMaterial({
    map: textureLoader.load(`${textureURLBase}mars.jpg`),
    shininess: 5
  });
  const mars = new THREE.Mesh(marsGeometry, marsMaterial);
  marsGroup.add(mars);

  const marsAtmosphereGeometry = new THREE.SphereGeometry(0.53, 64, 64);
  const marsAtmosphereMaterial = new THREE.MeshPhongMaterial({
    color: 0xEE8D70,
    transparent: true,
    opacity: 0.05,
    side: THREE.BackSide
  });
  const marsAtmosphere = new THREE.Mesh(marsAtmosphereGeometry, marsAtmosphereMaterial);
  marsGroup.add(marsAtmosphere);
  scene.add(marsGroup);

  const venusGroup = new THREE.Group();
  const venusGeometry = new THREE.SphereGeometry(0.75, 64, 64);
  const venusMaterial = new THREE.MeshPhongMaterial({
    map: textureLoader.load(`${textureURLBase}venus.jpg`),
    shininess: 8
  });
  const venus = new THREE.Mesh(venusGeometry, venusMaterial);
  venusGroup.add(venus);

  const venusAtmosphereGeometry = new THREE.SphereGeometry(0.78, 64, 64);
  const venusAtmosphereMaterial = new THREE.MeshPhongMaterial({
    color: 0xFFD700,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  });
  const venusAtmosphere = new THREE.Mesh(venusAtmosphereGeometry, venusAtmosphereMaterial);
  venusGroup.add(venusAtmosphere);
  scene.add(venusGroup);

  // Mercury setup
  const mercuryGroup = new THREE.Group();
  const mercuryGeometry = new THREE.SphereGeometry(0.3, 64, 64);
  const mercuryMaterial = new THREE.MeshPhongMaterial({
    map: textureLoader.load(`${textureURLBase}mercury.jpg`),
    shininess: 5
  });
  const mercury = new THREE.Mesh(mercuryGeometry, mercuryMaterial);
  mercuryGroup.add(mercury);
  scene.add(mercuryGroup);

  // Sun setup
  const sunGroup = new THREE.Group();
  const sunGeometry = new THREE.SphereGeometry(2, 64, 64);
  const sunMaterial = new THREE.MeshBasicMaterial({
    map: textureLoader.load(`${textureURLBase}sun.jpg`)
  });
  const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
  sunGroup.add(sunMesh);
  scene.add(sunGroup);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(-15, 8, 0);
  scene.add(directionalLight);

  const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
  scene.add(ambientLight);

  function getOrbitConfig() {
    const isMobile = window.innerWidth < 768;
    const scale = isMobile ? 0.6 : 1;
    
    return {
      mars: { 
        a: 10 * scale, 
        b: 3 * scale, 
        angle: Math.PI / 6, 
        phase: 0.5, 
        offsetX: isMobile ? 1.5 * scale : 3 * scale, 
        offsetY: isMobile ? -8 * scale : -4 * scale 
      },
      earth: { 
        a: 8 * scale, 
        b: 3 * scale, 
        angle: Math.PI / 6, 
        phase: 0, 
        offsetX: isMobile ? 1 * scale : 1 * scale, 
        offsetY: isMobile ? -2 : 0, 
      },
      venus: { 
        a: 5 * scale, 
        b: 2 * scale, 
        angle: Math.PI / 6, 
        phase: 0.3, 
        offsetX: isMobile ? -2.5 * scale : -5 * scale, 
        offsetY: isMobile ? 3 * scale : 3 * scale 
      },
      mercury: { 
        a: 4 * scale, 
        b: 1 * scale, 
        angle: Math.PI / 6, 
        phase: 1, 
        offsetX: isMobile ? -2 * scale : -10 * scale, 
        offsetY: isMobile ? 8 * scale : 6 * scale 
      }
    };
  }

  earth.rotation.x = THREE.MathUtils.degToRad(23.5);
  mars.rotation.x = THREE.MathUtils.degToRad(25.2);
  venus.rotation.x = THREE.MathUtils.degToRad(177.4);
  mercury.rotation.x = THREE.MathUtils.degToRad(0.03);

  function updateCameraPosition() {
    const isMobile = window.innerWidth < 768;
    camera.position.z = isMobile ? 15 : 12;
    camera.updateProjectionMatrix();
  }
  
  updateCameraPosition();

  let time = 0;

  function updateSunPosition() {
    const aspect = width / height;
    const vFov = THREE.MathUtils.degToRad(camera.fov);
    const hFov = 2 * Math.atan(Math.tan(vFov / 2) * aspect);

    const top = Math.tan(vFov / 2) * camera.position.z;
    const left = -Math.tan(hFov / 2) * camera.position.z;

    // Adjust sun position based on screen size
    const isMobile = window.innerWidth < 768;
    const sunX = isMobile ? left + 1 : left + 2;
    const sunY = isMobile ? top - 1 : top - 2;
    
    sunGroup.position.set(sunX, sunY, 0);
    directionalLight.position.set(sunX, sunY, 0);
  }

  function animate() {
    requestAnimationFrame(animate);
    time += 0.005;

    const orbits = getOrbitConfig();

    function updateOrbit(group, params, speed) {
      const rawX = params.a * Math.cos(time * speed + params.phase);
      const rawY = params.b * Math.sin(time * speed + params.phase);
      const x = rawX * Math.cos(params.angle) - rawY * Math.sin(params.angle) + params.offsetX;
      const y = rawY * Math.cos(params.angle) + rawX * Math.sin(params.angle) + params.offsetY;
      group.position.set(x, y, 0);
    }

    updateOrbit(earthGroup, orbits.earth, 1);
    updateOrbit(marsGroup, orbits.mars, 0.7);
    updateOrbit(venusGroup, orbits.venus, 1.2);
    updateOrbit(mercuryGroup, orbits.mercury, 1.5);

    earth.rotation.y += 0.01;
    clouds.rotation.y += 0.0115;
    mars.rotation.y += 0.0097;
    venus.rotation.y += 0.0004;
    mercury.rotation.y += 0.0017;
    sunMesh.rotation.z += 0.003;
    sunMesh.rotation.y += 0.003;

    renderer.render(scene, camera);
  }

  function onResize() {
    width = container.clientWidth;
    height = container.clientHeight;
    camera.aspect = width / height;
    updateCameraPosition();
    renderer.setSize(width, height);
    updateSunPosition();
  }

  window.addEventListener('resize', onResize);
  updateSunPosition();
  animate();
});
</script>

<style>
.earth-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  overflow: hidden;
}
#solar-canvas {
  width: 100%;
  height: 100%;
  display: block;
}
</style>
